name: üê≥ Docker Build & Deploy

# Prevent concurrent deployments
concurrency:
  group: production-deploy
  cancel-in-progress: false

on:
  push:
    branches: [ master, main ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  PRODUCTION_SERVER: "129.80.244.212"
  PRODUCTION_USER: "ubuntu"

permissions:
  contents: read          # Required for checkout
  packages: write         # Required for pushing to GHCR
  id-token: write        # Required for OIDC token generation
  actions: read          # Required for build attestations
  attestations: write    # Required for build attestations

jobs:
  # Build and push Docker image to GHCR
  build-and-push:
    name: üèóÔ∏è Build & Push Docker Image
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.resolve-tag.outputs.image_tag }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîß Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîë Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üè∑Ô∏è Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: üéØ Resolve deployment tag
        id: resolve-tag
        run: |
          SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-12)
          if [[ "${{ github.ref_name }}" == "master" ]]; then
            echo "image_tag=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:master-${SHORT_SHA}" >> "$GITHUB_OUTPUT"
          else
            echo "image_tag=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.ref_name }}-${SHORT_SHA}" >> "$GITHUB_OUTPUT"
          fi

      - name: üèóÔ∏è Build and push Docker image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: |
            type=gha
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: |
            type=gha,mode=max
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max
          provenance: true
          sbom: true

      - name: üß™ Test Docker image locally
        run: |
          echo "üß™ Testing Docker image locally..."
          
          # Use the resolved deployment tag
          IMAGE_TAG="${{ steps.resolve-tag.outputs.image_tag }}"
          echo "Testing image: $IMAGE_TAG"
          
          # Start container for testing
          docker run -d --name test-portfolio -p 8000:8000 \
            -e SERVER_ENV=production \
            -e SERVER_PORT=8000 \
            -e SECURITY_JWT_SECRET="test-secret" \
            -e SECURITY_SESSION_SECRET="test-secret" \
            $IMAGE_TAG
          
          # Wait for container to be ready
          echo "‚è≥ Waiting for container to start..."
          for i in {1..30}; do
            if curl -f http://localhost:8000/health > /dev/null 2>&1; then
              echo "‚úÖ Container health check passed!"
              break
            elif [ $i -eq 30 ]; then
              echo "‚ùå Container health check failed"
              docker logs test-portfolio
              exit 1
            fi
            echo "  Health check attempt $i/30..."
            sleep 2
          done
          
          # Test homepage
          HOMEPAGE_SIZE=$(curl -s http://localhost:8000 | wc -c)
          if [ "$HOMEPAGE_SIZE" -gt 1000 ]; then
            echo "‚úÖ Homepage test passed (${HOMEPAGE_SIZE} bytes)"
          else
            echo "‚ùå Homepage test failed (${HOMEPAGE_SIZE} bytes)"
            exit 1
          fi
          
          # Cleanup
          docker stop test-portfolio
          docker rm test-portfolio

  # Deploy to production server
  deploy-production:
    name: üöÄ Deploy to Production
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    environment: 
      name: production
      url: http://129.80.244.212:8000
    env:
      SERVER_ENV: ${{ vars.SERVER_ENV }}
      SERVER_PORT: ${{ vars.SERVER_PORT }}
      SERVER_LOG_LEVEL: ${{ vars.SERVER_LOG_LEVEL }}
      SECURITY_CORS_ORIGINS: ${{ vars.SECURITY_CORS_ORIGINS }}
      SECURITY_RATE_LIMIT_RPS: ${{ vars.SECURITY_RATE_LIMIT_RPS }}
      SECURITY_JWT_SECRET: ${{ secrets.SECURITY_JWT_SECRET }}
      SECURITY_SESSION_SECRET: ${{ secrets.SECURITY_SESSION_SECRET }}
      BUGSNAG_API_KEY: ${{ secrets.BUGSNAG_API_KEY }}
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîß Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: üìù Create deployment script
        run: |
          cat > deploy.sh << 'EOF'
          #!/bin/bash
          set -e
          
          echo "üöÄ Starting deployment..."
          
          # Configuration
          IMAGE_TAG="${{ needs.build-and-push.outputs.image-tag }}"
          CONTAINER_NAME="portfolio-app"
          DEPLOY_DIR="/opt/portfolio"
          
          echo "Deploying image: $IMAGE_TAG"
          
          # Validate image tag
          if [ -z "$IMAGE_TAG" ]; then
            echo "‚ùå Error: IMAGE_TAG is empty"
            echo "Available outputs:"
            echo "  image-tag: '${{ needs.build-and-push.outputs.image-tag }}'"
            exit 1
          fi
          
          # Clean the IMAGE_TAG to ensure it's a single line (remove any newlines)
          IMAGE_TAG=$(echo "$IMAGE_TAG" | tr -d '\n\r' | awk '{print $1}')
          echo "Cleaned IMAGE_TAG: $IMAGE_TAG"
          
          # Create deployment directory
          sudo mkdir -p $DEPLOY_DIR
          sudo chown $USER:$USER $DEPLOY_DIR
          cd $DEPLOY_DIR
          
          # Login to Docker registry
          echo "üîë Logging into Docker registry..."
          echo '${{ secrets.GITHUB_TOKEN }}' | docker login ghcr.io -u '${{ github.actor }}' --password-stdin
          
          # Create environment file
          echo "üìù Creating environment file..."
          cat > .env << ENVEOF
          SERVER_ENV=$SERVER_ENV
          SERVER_PORT=$SERVER_PORT
          SERVER_LOG_LEVEL=$SERVER_LOG_LEVEL
          SECURITY_JWT_SECRET=$SECURITY_JWT_SECRET
          SECURITY_SESSION_SECRET=$SECURITY_SESSION_SECRET
          SECURITY_CORS_ORIGINS=$SECURITY_CORS_ORIGINS
          SECURITY_RATE_LIMIT_RPS=$SECURITY_RATE_LIMIT_RPS
          BUGSNAG_API_KEY=$BUGSNAG_API_KEY
          ENVEOF
          chmod 600 .env
          
          # Pull new image
          echo "üì• Pulling new Docker image..."
          docker pull $IMAGE_TAG
          
          # Store current image for rollback
          CURRENT_IMAGE=""
          if docker ps | grep -q $CONTAINER_NAME; then
            CURRENT_IMAGE=$(docker inspect $CONTAINER_NAME --format='{{.Config.Image}}' 2>/dev/null || echo "")
            echo "Current image for rollback: $CURRENT_IMAGE"
          fi
          
          # Preflight test with new image
          echo "üß™ Preflight testing new image..."
          docker run -d --name ${CONTAINER_NAME}-preflight \
            --env-file .env \
            -p 8001:8000 \
            $IMAGE_TAG
          
          # Wait for preflight container to be healthy
          PREFLIGHT_HEALTHY=false
          for i in {1..30}; do
            if curl -f http://localhost:8001/health > /dev/null 2>&1; then
              echo "‚úÖ Preflight health check passed!"
              PREFLIGHT_HEALTHY=true
              break
            fi
            echo "  Preflight attempt $i/30..."
            sleep 3
          done
          
          # Stop preflight container
          docker stop ${CONTAINER_NAME}-preflight || true
          docker rm ${CONTAINER_NAME}-preflight || true
          
          if [ "$PREFLIGHT_HEALTHY" = false ]; then
            echo "‚ùå Preflight failed - aborting deployment"
            exit 1
          fi
          
          # Stop and remove existing container
          if docker ps | grep -q $CONTAINER_NAME; then
            echo "üõë Stopping existing container..."
            docker stop $CONTAINER_NAME || true
            docker rm $CONTAINER_NAME || true
          fi
          
          # Start new container
          echo "üèÉ Starting new container..."
          docker run -d --name $CONTAINER_NAME \
            --env-file .env \
            -p 8000:8000 \
            --restart unless-stopped \
            $IMAGE_TAG
          
          # Wait for container to be healthy
          echo "‚è≥ Waiting for new container to be ready..."
          DEPLOY_HEALTHY=false
          for i in {1..60}; do
            if curl -f http://localhost:8000/health > /dev/null 2>&1; then
              echo "‚úÖ Deployment successful!"
              DEPLOY_HEALTHY=true
              break
            fi
            echo "  Health check attempt $i/60..."
            sleep 3
          done
          
          # Rollback if deployment failed
          if [ "$DEPLOY_HEALTHY" = false ]; then
            echo "‚ùå Deployment health check failed"
            docker logs $CONTAINER_NAME || true
            
            if [ ! -z "$CURRENT_IMAGE" ]; then
              echo "üîÑ Rolling back to previous image: $CURRENT_IMAGE"
              docker stop $CONTAINER_NAME || true
              docker rm $CONTAINER_NAME || true
              docker run -d --name $CONTAINER_NAME \
                --env-file .env \
                -p 8000:8000 \
                --restart unless-stopped \
                $CURRENT_IMAGE
              
              # Verify rollback
              for i in {1..30}; do
                if curl -f http://localhost:8000/health > /dev/null 2>&1; then
                  echo "‚úÖ Rollback successful"
                  break
                elif [ $i -eq 30 ]; then
                  echo "‚ùå Rollback also failed"
                fi
                sleep 2
              done
            fi
            exit 1
          fi
          
          # Cleanup old images (keep last 3)
          echo "üßπ Cleaning up old images..."
          docker images --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | \
            grep "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}" | \
            tail -n +4 | \
            awk '{print $1}' | \
            xargs -r docker rmi || true
          
          echo "üéâ Deployment completed successfully!"
          EOF
          
          chmod +x deploy.sh

      - name: üì§ Transfer deployment script
        run: |
          scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
              deploy.sh ${{ env.PRODUCTION_USER }}@${{ env.PRODUCTION_SERVER }}:/tmp/

      - name: üöÄ Execute deployment
        run: |
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
              ${{ env.PRODUCTION_USER }}@${{ env.PRODUCTION_SERVER }} \
              "chmod +x /tmp/deploy.sh && /tmp/deploy.sh"

      - name: üè• Final health check
        run: |
          echo "üè• Running final health check..."
          
          # Wait a moment for services to fully stabilize
          sleep 5
          
          # Test health endpoint
          if curl -f http://${{ env.PRODUCTION_SERVER }}:8000/health; then
            echo "‚úÖ Production health check passed"
          else
            echo "‚ùå Production health check failed"
            exit 1
          fi
          
          # Test homepage
          HOMEPAGE_SIZE=$(curl -s http://${{ env.PRODUCTION_SERVER }}:8000/ | wc -c)
          if [ "$HOMEPAGE_SIZE" -gt 1000 ]; then
            echo "‚úÖ Homepage accessible (${HOMEPAGE_SIZE} bytes)"
          else
            echo "‚ùå Homepage test failed (${HOMEPAGE_SIZE} bytes)"
            exit 1
          fi
          
          # Performance check
          RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' http://${{ env.PRODUCTION_SERVER }}:8000/ || echo "timeout")
          echo "‚ö° Response time: ${RESPONSE_TIME}s"
          
          echo "üéâ All health checks passed - deployment verified!"

      - name: üì¢ Notify on failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'üö® Production Deployment Failed',
              body: `## üö® Production Deployment Alert
              
              **Time**: ${new Date().toISOString()}
              **Server**: ${{ env.PRODUCTION_SERVER }}
              **Commit**: ${{ github.sha }}
              **Workflow**: [${context.workflow}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})
              
              ### ‚ùå Deployment Failed
              The automated deployment to production has failed.
              
              ### üîç Next Steps:
              1. Check the workflow logs for detailed error information
              2. Verify server status and connectivity
              3. Check Docker container status on the production server
              4. Review application logs if the container started
              
              **This issue was automatically created by GitHub Actions.**`,
              labels: ['bug', 'production', 'deployment', 'urgent']
            });