name: üê≥ Docker Build & Deploy

# Prevent concurrent deployments
concurrency:
  group: ${{ github.workflow }}-${{ github.ref_name }}
  cancel-in-progress: false

on:
  push:
    branches: [ master, main ]
  pull_request:
    branches: [ master, main ]
  workflow_dispatch:
  schedule:
    # Health checks every 6 hours (like CircleCI)
    - cron: '0 */6 * * *'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  PRODUCTION_SERVER: "129.80.244.212"
  PRODUCTION_USER: "ubuntu"

permissions:
  contents: read          # Required for checkout
  packages: write         # Required for pushing to GHCR
  id-token: write        # Required for OIDC token generation
  actions: read          # Required for build attestations
  attestations: write    # Required for build attestations
  security-events: write # Required for uploading SARIF results

jobs:
  # Enhanced Docker build with multi-platform support
  build-and-test:
    name: üèóÔ∏è Build & Test Docker
    runs-on: ubuntu-latest
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tag: ${{ fromJSON(steps.meta.outputs.json).tags[0] }}
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîç Run Dockerfile security scan
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: Dockerfile
          failure-threshold: error
          no-fail: true

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/amd64,linux/arm64
          install: true

      - name: üîë Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üè∑Ô∏è Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=schedule,pattern={{date 'YYYYMMDD'}}
          labels: |
            org.opencontainers.image.title=Portfolio Website
            org.opencontainers.image.description=Interactive personal portfolio with Go backend and WASM frontend
            org.opencontainers.image.vendor=dav88dev
            org.opencontainers.image.url=https://dav88.dev
            org.opencontainers.image.source=https://github.com/dav88dev/dav88dev
            org.opencontainers.image.documentation=https://github.com/dav88dev/dav88dev#readme
            org.opencontainers.image.licenses=MIT
          annotations: |
            org.opencontainers.image.title=Portfolio Website
            org.opencontainers.image.description=Interactive personal portfolio with Go backend and WASM frontend
            org.opencontainers.image.vendor=dav88dev
          flavor: |
            latest=auto

      - name: üèóÔ∏è Build and push Docker image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          annotations: ${{ steps.meta.outputs.annotations }}
          cache-from: |
            type=gha
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: |
            type=gha,mode=max
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1
          provenance: true
          sbom: true

      - name: üß™ Test Docker image (Health Check)
        run: |
          echo "üß™ Testing Docker image..."
          
          # Pull the image we just built
          IMAGE_TAG="$(echo '${{ steps.meta.outputs.tags }}' | head -n1)"
          echo "Testing image: $IMAGE_TAG"
          docker pull $IMAGE_TAG
          
          # Start container for testing
          docker run -d --name test-portfolio -p 8000:8000 \
            -e SERVER_ENV=production \
            -e SERVER_PORT=8000 \
            -e SECURITY_JWT_SECRET="test-jwt-secret" \
            -e SECURITY_SESSION_SECRET="test-session-secret" \
            $IMAGE_TAG
          
          # Wait for container to be ready (improved logic)
          echo "‚è≥ Waiting for container to start..."
          for i in {1..30}; do
            if curl -f http://localhost:8000/health > /dev/null 2>&1; then
              echo "‚úÖ Container is healthy!"
              break
            elif [ $i -eq 30 ]; then
              echo "‚ùå Container failed to start"
              docker logs test-portfolio
              exit 1
            fi
            echo "  Attempt $i/30..."
            sleep 2
          done
          
          # Advanced health tests
          echo "üîç Running comprehensive health tests..."
          
          # Test health endpoint
          HEALTH_RESPONSE=$(curl -s http://localhost:8000/health)
          echo "Health response: $HEALTH_RESPONSE"
          
          # Test homepage size
          HOMEPAGE_SIZE=$(curl -s http://localhost:8000 | wc -c)
          if [ "$HOMEPAGE_SIZE" -gt 1000 ]; then
            echo "‚úÖ Homepage test passed (${HOMEPAGE_SIZE} bytes)"
          else
            echo "‚ùå Homepage test failed (${HOMEPAGE_SIZE} bytes)"
            docker logs test-portfolio
            exit 1
          fi
          
          # Test API endpoints
          if curl -f http://localhost:8000/api/cv > /dev/null 2>&1; then
            echo "‚úÖ API endpoint test passed"
          else
            echo "‚ö†Ô∏è  API endpoint test failed (may be expected)"
          fi
          
          # Container resource usage
          echo "üìä Container resource usage:"
          docker stats --no-stream test-portfolio
          
          # Cleanup
          docker stop test-portfolio
          docker rm test-portfolio

      - name: üîí Run Trivy security scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ fromJSON(steps.meta.outputs.json).tags[0] }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      # SARIF upload disabled - requires GitHub Advanced Security
      # Results are available in the scan output above

  # Enhanced deployment with zero-downtime
  deploy-production:
    name: üöÄ Deploy to Production
    runs-on: ubuntu-latest
    needs: build-and-test
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    environment: 
      name: production
      url: http://129.80.244.212
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîß Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: üìù Create deployment script
        run: |
          cat > deploy.sh << 'EOF'
          #!/bin/bash
          set -e
          
          echo "üöÄ Starting zero-downtime deployment..."
          
          # Configuration
          IMAGE_NAME="${{ needs.build-and-test.outputs.image-tag }}"
          echo "Deploying image: $IMAGE_NAME"
          CONTAINER_NAME="portfolio-app"
          CONTAINER_NAME_NEW="portfolio-app-new"
          
          # Login to Docker registry
          echo "üîë Logging into Docker registry..."
          echo '${{ secrets.GITHUB_TOKEN }}' | docker login ghcr.io -u '${{ github.actor }}' --password-stdin
          
          # Pull new image
          echo "üì• Pulling new Docker image..."
          docker pull $IMAGE_NAME
          
          # Start new container on different port
          echo "üèÉ Starting new container..."
          docker run -d --name $CONTAINER_NAME_NEW \
            -p 8001:8000 \
            -e SERVER_ENV='${{ secrets.SERVER_ENV }}' \
            -e SERVER_PORT=8000 \
            -e SERVER_LOG_LEVEL='${{ secrets.SERVER_LOG_LEVEL }}' \
            -e DB_MONGO_URI='${{ secrets.DB_MONGO_URI }}' \
            -e DB_MONGO_DATABASE='${{ secrets.DB_MONGO_DATABASE }}' \
            -e SECURITY_JWT_SECRET='${{ secrets.SECURITY_JWT_SECRET }}' \
            -e SECURITY_SESSION_SECRET='${{ secrets.SECURITY_SESSION_SECRET }}' \
            -e SECURITY_CORS_ORIGINS='https://dav88.dev' \
            -e SECURITY_RATE_LIMIT_RPS='${{ secrets.SECURITY_RATE_LIMIT_RPS }}' \
            -e BUGSNAG_API_KEY='${{ secrets.BUGSNAG_API_KEY }}' \
            --restart unless-stopped \
            $IMAGE_NAME
          
          # Wait for new container to be healthy
          echo "‚è≥ Waiting for new container to be ready..."
          for i in {1..30}; do
            if curl -f http://localhost:8001/health > /dev/null 2>&1; then
              echo "‚úÖ New container is healthy!"
              break
            elif [ $i -eq 30 ]; then
              echo "‚ùå New container failed to start"
              docker logs $CONTAINER_NAME_NEW
              docker stop $CONTAINER_NAME_NEW || true
              docker rm $CONTAINER_NAME_NEW || true
              exit 1
            fi
            sleep 2
          done
          
          # Switch traffic (zero-downtime)
          echo "üîÑ Switching traffic to new container..."
          
          # Update nginx or load balancer config here if using one
          # For now, we'll do a simple port switch
          
          # Stop old container
          if docker ps | grep -q $CONTAINER_NAME; then
            echo "üõë Stopping old container..."
            docker stop $CONTAINER_NAME || true
            docker rm $CONTAINER_NAME || true
          fi
          
          # Rename new container and switch port
          docker stop $CONTAINER_NAME_NEW
          docker rm $CONTAINER_NAME_NEW
          
          # Start final container on correct port
          docker run -d --name $CONTAINER_NAME \
            -p 8000:8000 \
            -e SERVER_ENV='${{ secrets.SERVER_ENV }}' \
            -e SERVER_PORT=8000 \
            -e SERVER_LOG_LEVEL='${{ secrets.SERVER_LOG_LEVEL }}' \
            -e DB_MONGO_URI='${{ secrets.DB_MONGO_URI }}' \
            -e DB_MONGO_DATABASE='${{ secrets.DB_MONGO_DATABASE }}' \
            -e SECURITY_JWT_SECRET='${{ secrets.SECURITY_JWT_SECRET }}' \
            -e SECURITY_SESSION_SECRET='${{ secrets.SECURITY_SESSION_SECRET }}' \
            -e SECURITY_CORS_ORIGINS='https://dav88.dev' \
            -e SECURITY_RATE_LIMIT_RPS='${{ secrets.SECURITY_RATE_LIMIT_RPS }}' \
            -e BUGSNAG_API_KEY='${{ secrets.BUGSNAG_API_KEY }}' \
            --restart unless-stopped \
            $IMAGE_NAME
          
          # Final health check with better debugging
          echo "‚è≥ Waiting for final container to be ready..."
          for i in {1..30}; do
            if curl -f http://localhost:8000/health > /dev/null 2>&1; then
              echo "‚úÖ Deployment successful!"
              break
            elif [ $i -eq 30 ]; then
              echo "‚ùå Final health check failed"
              echo "üîç Container status:"
              docker ps -a | grep $CONTAINER_NAME || echo "No container found"
              echo "üîç Container logs:"
              docker logs $CONTAINER_NAME || echo "No logs available"
              echo "üîç Port usage:"
              netstat -tlnp | grep :8000 || echo "Port 8000 not in use"
              exit 1
            fi
            echo "  Health check attempt $i/30..."
            sleep 2
          done
          
          # Cleanup old images (keep last 3)
          echo "üßπ Cleaning up old images..."
          docker images --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | \
            grep "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}" | \
            tail -n +4 | \
            awk '{print $1}' | \
            xargs -r docker rmi || true
          
          echo "üéâ Zero-downtime deployment completed!"
          EOF
          
          chmod +x deploy.sh

      - name: üì§ Transfer deployment script
        run: |
          scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
              deploy.sh ${{ env.PRODUCTION_USER }}@${{ env.PRODUCTION_SERVER }}:/tmp/

      - name: üöÄ Execute deployment
        run: |
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
              ${{ env.PRODUCTION_USER }}@${{ env.PRODUCTION_SERVER }} \
              "chmod +x /tmp/deploy.sh && /tmp/deploy.sh"

      - name: üè• Post-deployment health check
        run: |
          echo "üè• Running post-deployment health checks..."
          
          # Wait a moment for services to fully start
          sleep 10
          
          # Basic health check
          if curl -f http://${{ env.PRODUCTION_SERVER }}:8000/health; then
            echo "‚úÖ Health check passed"
          else
            echo "‚ùå Health check failed"
            exit 1
          fi
          
          # Performance check
          RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' http://${{ env.PRODUCTION_SERVER }}:8000/)
          echo "‚ö° Response time: ${RESPONSE_TIME}s"
          
          if (( $(echo "$RESPONSE_TIME < 2.0" | bc -l) )); then
            echo "‚úÖ Performance check passed"
          else
            echo "‚ö†Ô∏è  Response time higher than expected"
          fi

  # Scheduled health monitoring (replaces CircleCI cron)
  health-check:
    name: üè• Health Check
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: üè• Production health check
        run: |
          echo "üè• Comprehensive production health check..."
          
          SERVER_URL="http://${{ env.PRODUCTION_SERVER }}:8000"
          
          # Health endpoint check
          echo "1Ô∏è‚É£ Testing health endpoint..."
          if HEALTH_RESPONSE=$(curl -f -s "$SERVER_URL/health"); then
            echo "‚úÖ Health endpoint: OK"
            echo "$HEALTH_RESPONSE" | jq . 2>/dev/null || echo "$HEALTH_RESPONSE"
          else
            echo "‚ùå Health endpoint: FAILED"
            exit 1
          fi
          
          # Homepage check
          echo "2Ô∏è‚É£ Testing homepage..."
          HOMEPAGE_SIZE=$(curl -s "$SERVER_URL/" | wc -c)
          if [ "$HOMEPAGE_SIZE" -gt 1000 ]; then
            echo "‚úÖ Homepage: OK (${HOMEPAGE_SIZE} bytes)"
          else
            echo "‚ùå Homepage: FAILED (${HOMEPAGE_SIZE} bytes)"
            exit 1
          fi
          
          # API endpoint check
          echo "3Ô∏è‚É£ Testing API endpoints..."
          if curl -f -s "$SERVER_URL/api/cv" > /dev/null; then
            echo "‚úÖ API endpoints: OK"
          else
            echo "‚ö†Ô∏è  API endpoints: May not be configured"
          fi
          
          # Performance check
          echo "4Ô∏è‚É£ Performance test..."
          RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' "$SERVER_URL/")
          echo "‚ö° Response time: ${RESPONSE_TIME}s"
          
          # SSL/Security check (if using HTTPS)
          echo "5Ô∏è‚É£ Security check..."
          SECURITY_HEADERS=$(curl -s -I "$SERVER_URL/" | grep -i "x-\|content-security\|strict-transport")
          if [ ! -z "$SECURITY_HEADERS" ]; then
            echo "‚úÖ Security headers present:"
            echo "$SECURITY_HEADERS"
          else
            echo "‚ö†Ô∏è  No security headers detected"
          fi
          
          echo "üéâ All health checks completed!"

      - name: üì¢ Notify on failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'üö® Production Health Check Failed',
              body: `## üö® Production Health Check Alert
              
              **Time**: ${new Date().toISOString()}
              **Server**: ${{ env.PRODUCTION_SERVER }}
              **Workflow**: [${context.workflow}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})
              
              ### ‚ùå Health Check Failed
              The automated health check for the production server has failed.
              
              ### üîç Recommended Actions:
              1. Check server status manually
              2. Review server logs
              3. Verify Docker container status
              4. Check network connectivity
              
              ### üìä Check Details:
              - Health endpoint test
              - Homepage accessibility  
              - API endpoint functionality
              - Performance metrics
              
              **This issue was automatically created by GitHub Actions.**`,
              labels: ['bug', 'production', 'health-check', 'urgent']
            });

  # Container registry cleanup
  cleanup-registry:
    name: üßπ Registry Cleanup
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule'
    
    steps:
      - name: üßπ Clean old container images
        uses: actions/delete-package-versions@v5
        with:
          package-name: ${{ env.IMAGE_NAME }}
          package-type: 'container'
          min-versions-to-keep: 5
          delete-only-untagged-versions: true