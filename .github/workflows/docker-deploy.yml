name: 🐳 Docker Build & Deploy

# Prevent concurrent deployments
concurrency:
  group: production-deploy
  cancel-in-progress: false

on:
  push:
    branches: [ master, main ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  PRODUCTION_SERVER: "129.80.244.212"
  PRODUCTION_USER: "ubuntu"

permissions:
  contents: read          # Required for checkout
  packages: write         # Required for pushing to GHCR
  id-token: write        # Required for OIDC token generation
  actions: read          # Required for build attestations
  attestations: write    # Required for build attestations

jobs:
  # Quality gates - Go testing and validation before build
  test-and-quality:
    name: 🧪 Go Tests & Quality Gates
    runs-on: ubuntu-latest
    steps:
      - name: 📥 Checkout repository
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
        # Pin: actions/checkout@v4 (2025 security - SHA pinned for supply chain protection)

      - name: 🐹 Set up Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5
        # Pin: actions/setup-go@v5 (2025 security - SHA pinned for supply chain protection)
        with:
          go-version: '1.24'
          cache: true

      - name: 📦 Download dependencies
        run: go mod download

      - name: 🔍 Verify dependencies
        run: go mod verify

      - name: ⚡ Run Go tests with race detection
        run: |
          echo "🧪 Running Go tests with race detection..."
          go test -race -shuffle=on -coverprofile=coverage.out -covermode=atomic ./...

      - name: 📊 Check coverage threshold (4% minimum)
        run: |
          echo "📊 Checking test coverage threshold..."
          COVERAGE=$(go tool cover -func=coverage.out | awk '/^total:/{print $3}' | sed 's/%//')
          echo "Current coverage: ${COVERAGE}%"
          MINIMUM_COVERAGE=4
          if (( $(echo "$COVERAGE < $MINIMUM_COVERAGE" | bc -l) )); then
            echo "❌ Coverage ${COVERAGE}% is below ${MINIMUM_COVERAGE}% threshold"
            exit 1
          else
            echo "✅ Coverage ${COVERAGE}% meets ${MINIMUM_COVERAGE}% threshold"
            if (( $(echo "$COVERAGE >= 30" | bc -l) )); then
              echo "🎯 Excellent! Coverage is above 30% - production ready!"
            elif (( $(echo "$COVERAGE >= 15" | bc -l) )); then
              echo "👍 Good! Coverage is above 15% - getting there!"
            elif (( $(echo "$COVERAGE >= 10" | bc -l) )); then
              echo "📈 Fair! Coverage is above 10% - room for improvement"
            fi
          fi

      - name: 🎯 Go vet analysis
        run: |
          echo "🎯 Running go vet..."
          go vet ./...

      - name: 📝 Check Go formatting
        run: |
          echo "📝 Checking Go formatting..."
          if [ "$(go fmt ./... | wc -l)" -gt 0 ]; then
            echo "❌ Go files need formatting"
            go fmt ./...
            exit 1
          else
            echo "✅ All Go files properly formatted"
          fi

      - name: 🔒 Security scan with govulncheck
        run: |
          echo "🔒 Installing govulncheck..."
          go install golang.org/x/vuln/cmd/govulncheck@latest
          echo "🔍 Running security vulnerability scan..."
          export PATH=$PATH:$(go env GOPATH)/bin
          govulncheck ./...

  # Build and push Docker image to GHCR
  build-and-push:
    name: 🏗️ Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: test-and-quality  # Quality gates must pass before build
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: 📥 Checkout repository
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
        # Pin: actions/checkout@v4 (2025 security - SHA pinned for supply chain protection)

      - name: 🔧 Set up QEMU
        uses: docker/setup-qemu-action@29109295f81e9208d7d86ff1c6c12d2833863392
        # Pin: docker/setup-qemu-action@v3 (2025 security - SHA pinned for supply chain protection)

      - name: 🐳 Set up Docker Buildx
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435
        # Pin: docker/setup-buildx-action@v3 (2025 security - SHA pinned for supply chain protection)

      - name: 🔑 Log in to Container Registry
        uses: docker/login-action@184bdaa0721073962dff0199f1fb9940f07167d1
        # Pin: docker/login-action@v3 (2025 security - SHA pinned for supply chain protection)
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: 🏷️ Extract metadata
        id: meta
        uses: docker/metadata-action@c1e51972afc2121e065aed6d45c65596fe445f3f
        # Pin: docker/metadata-action@v5 (2025 security - SHA pinned for supply chain protection)
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix={{branch}}-,format=short
            type=raw,value=latest,enable={{is_default_branch}}


      - name: 🏗️ Build and push Docker image
        id: build
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83
        # Pin: docker/build-push-action@v6 (2025 security - SHA pinned for supply chain protection)
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: |
            type=gha
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: |
            type=gha,mode=max
            type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max
          provenance: true
          sbom: true

      - name: 🧪 Test Docker image locally
        run: |
          echo "🧪 Testing Docker image locally..."
          
          # Use the first tag from metadata action (should match what was pushed)
          IMAGE_TAG=$(echo "${{ steps.meta.outputs.tags }}" | head -n1)
          echo "Testing image: $IMAGE_TAG"
          
          # Start container for testing
          docker run -d --name test-portfolio -p 8000:8000 \
            -e SERVER_ENV=production \
            -e SERVER_PORT=8000 \
            -e SECURITY_JWT_SECRET="test-secret" \
            -e SECURITY_SESSION_SECRET="test-secret" \
            $IMAGE_TAG
          
          # Wait for container to be ready
          echo "⏳ Waiting for container to start..."
          for i in {1..30}; do
            if curl -f http://localhost:8000/health > /dev/null 2>&1; then
              echo "✅ Container health check passed!"
              break
            elif [ $i -eq 30 ]; then
              echo "❌ Container health check failed"
              docker logs test-portfolio
              exit 1
            fi
            echo "  Health check attempt $i/30..."
            sleep 2
          done
          
          # Test homepage
          HOMEPAGE_SIZE=$(curl -s http://localhost:8000 | wc -c)
          if [ "$HOMEPAGE_SIZE" -gt 1000 ]; then
            echo "✅ Homepage test passed (${HOMEPAGE_SIZE} bytes)"
          else
            echo "❌ Homepage test failed (${HOMEPAGE_SIZE} bytes)"
            exit 1
          fi
          
          # Cleanup
          docker stop test-portfolio
          docker rm test-portfolio

  # Deploy to production server
  deploy-production:
    name: 🚀 Deploy to Production
    runs-on: ubuntu-latest
    needs: [test-and-quality, build-and-push]  # Both quality gates and build must pass
    if: github.ref == 'refs/heads/master' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')
    environment: 
      name: production
      url: http://129.80.244.212:8000
    env:
      SERVER_ENV: ${{ vars.SERVER_ENV }}
      SERVER_PORT: ${{ vars.SERVER_PORT }}
      SERVER_LOG_LEVEL: ${{ vars.SERVER_LOG_LEVEL }}
      SECURITY_CORS_ORIGINS: ${{ vars.SECURITY_CORS_ORIGINS }}
      SECURITY_RATE_LIMIT_RPS: ${{ vars.SECURITY_RATE_LIMIT_RPS }}
      SECURITY_JWT_SECRET: ${{ secrets.SECURITY_JWT_SECRET }}
      SECURITY_SESSION_SECRET: ${{ secrets.SECURITY_SESSION_SECRET }}
      BUGSNAG_API_KEY: ${{ secrets.BUGSNAG_API_KEY }}
    
    steps:
      - name: 📥 Checkout repository
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955
        # Pin: actions/checkout@v4 (2025 security - SHA pinned for supply chain protection)

      - name: 🔧 Setup SSH
        uses: webfactory/ssh-agent@dc588b651fe13675774614f8e6a936a468676387
        # Pin: webfactory/ssh-agent@v0.9.0 (2025 security - SHA pinned for supply chain protection)
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: 📝 Create deployment script
        run: |
          cat > deploy.sh << 'EOF'
          #!/bin/bash
          set -e
          
          echo "🚀 Starting deployment..."
          
          # Configuration - Use immutable digest reference for security
          IMAGE_DIGEST="${{ needs.build-and-push.outputs.image-digest }}"
          IMAGE_REF="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${IMAGE_DIGEST}"
          CONTAINER_NAME="portfolio-app"
          DEPLOY_DIR="/opt/portfolio"
          
          echo "Deploying image digest: $IMAGE_REF"
          
          # Validate image digest (immutable reference for security)
          if [ -z "$IMAGE_DIGEST" ]; then
            echo "❌ Error: IMAGE_DIGEST is empty"
            echo "Available outputs:"
            echo "  image-digest: '${{ needs.build-and-push.outputs.image-digest }}'"
            exit 1
          fi
          
          # Clean the IMAGE_DIGEST to ensure it's a single line
          IMAGE_DIGEST=$(echo "$IMAGE_DIGEST" | tr -d '\n\r' | awk '{print $1}')
          IMAGE_REF="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${IMAGE_DIGEST}"
          echo "Using immutable digest: $IMAGE_REF"
          
          # Create deployment directory
          sudo mkdir -p $DEPLOY_DIR
          sudo chown $USER:$USER $DEPLOY_DIR
          cd $DEPLOY_DIR
          
          # Login to Docker registry
          echo "🔑 Logging into Docker registry..."
          echo '${{ secrets.GITHUB_TOKEN }}' | docker login ghcr.io -u '${{ github.actor }}' --password-stdin
          
          # Create environment file
          echo "📝 Creating environment file..."
          cat > .env << ENVEOF
          SERVER_ENV=$SERVER_ENV
          SERVER_PORT=$SERVER_PORT
          SERVER_LOG_LEVEL=$SERVER_LOG_LEVEL
          SECURITY_JWT_SECRET=$SECURITY_JWT_SECRET
          SECURITY_SESSION_SECRET=$SECURITY_SESSION_SECRET
          SECURITY_CORS_ORIGINS=$SECURITY_CORS_ORIGINS
          SECURITY_RATE_LIMIT_RPS=$SECURITY_RATE_LIMIT_RPS
          BUGSNAG_API_KEY=$BUGSNAG_API_KEY
          ENVEOF
          chmod 600 .env
          
          # Pull new image using immutable digest
          echo "📥 Pulling new Docker image by digest..."
          docker pull $IMAGE_REF
          
          # Store current image for rollback
          CURRENT_IMAGE=""
          if docker ps | grep -q $CONTAINER_NAME; then
            CURRENT_IMAGE=$(docker inspect $CONTAINER_NAME --format='{{.Config.Image}}' 2>/dev/null || echo "")
            echo "Current image for rollback: $CURRENT_IMAGE"
          fi
          
          # Preflight test with new image
          echo "🧪 Preflight testing new image..."
          docker run -d --name ${CONTAINER_NAME}-preflight \
            --env-file .env \
            -p 8001:8000 \
            $IMAGE_REF
          
          # Wait for preflight container to be healthy
          PREFLIGHT_HEALTHY=false
          for i in {1..30}; do
            if curl -f http://localhost:8001/health > /dev/null 2>&1; then
              echo "✅ Preflight health check passed!"
              PREFLIGHT_HEALTHY=true
              break
            fi
            echo "  Preflight attempt $i/30..."
            sleep 3
          done
          
          # Stop preflight container
          docker stop ${CONTAINER_NAME}-preflight || true
          docker rm ${CONTAINER_NAME}-preflight || true
          
          if [ "$PREFLIGHT_HEALTHY" = false ]; then
            echo "❌ Preflight failed - aborting deployment"
            exit 1
          fi
          
          # Stop and remove existing container
          if docker ps | grep -q $CONTAINER_NAME; then
            echo "🛑 Stopping existing container..."
            docker stop $CONTAINER_NAME || true
            docker rm $CONTAINER_NAME || true
          fi
          
          # Start new container with immutable digest
          echo "🏃 Starting new container..."
          docker run -d --name $CONTAINER_NAME \
            --env-file .env \
            -p 8000:8000 \
            --restart unless-stopped \
            $IMAGE_REF
          
          # Wait for container to be healthy
          echo "⏳ Waiting for new container to be ready..."
          DEPLOY_HEALTHY=false
          for i in {1..60}; do
            if curl -f http://localhost:8000/health > /dev/null 2>&1; then
              echo "✅ Deployment successful!"
              DEPLOY_HEALTHY=true
              break
            fi
            echo "  Health check attempt $i/60..."
            sleep 3
          done
          
          # Rollback if deployment failed
          if [ "$DEPLOY_HEALTHY" = false ]; then
            echo "❌ Deployment health check failed"
            docker logs $CONTAINER_NAME || true
            
            if [ ! -z "$CURRENT_IMAGE" ]; then
              echo "🔄 Rolling back to previous image: $CURRENT_IMAGE"
              docker stop $CONTAINER_NAME || true
              docker rm $CONTAINER_NAME || true
              docker run -d --name $CONTAINER_NAME \
                --env-file .env \
                -p 8000:8000 \
                --restart unless-stopped \
                $CURRENT_IMAGE
              
              # Verify rollback
              for i in {1..30}; do
                if curl -f http://localhost:8000/health > /dev/null 2>&1; then
                  echo "✅ Rollback successful"
                  break
                elif [ $i -eq 30 ]; then
                  echo "❌ Rollback also failed"
                fi
                sleep 2
              done
            fi
            exit 1
          fi
          
          # Cleanup old images (keep last 3)
          echo "🧹 Cleaning up old images..."
          docker images --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | \
            grep "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}" | \
            tail -n +4 | \
            awk '{print $1}' | \
            xargs -r docker rmi || true
          
          echo "🎉 Deployment completed successfully!"
          EOF
          
          chmod +x deploy.sh

      - name: 🔐 Setup secure SSH host verification
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          echo "${{ secrets.PROD_HOST_KEY }}" >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

      - name: 📤 Transfer deployment script  
        run: |
          scp deploy.sh ${{ env.PRODUCTION_USER }}@${{ env.PRODUCTION_SERVER }}:/tmp/

      - name: 🚀 Execute deployment
        run: |
          ssh ${{ env.PRODUCTION_USER }}@${{ env.PRODUCTION_SERVER }} \
              "chmod +x /tmp/deploy.sh && /tmp/deploy.sh"

      - name: 🏥 Final health check
        run: |
          echo "🏥 Running final health check..."
          
          # Wait a moment for services to fully stabilize
          sleep 5
          
          # Test health endpoint
          if curl -f http://${{ env.PRODUCTION_SERVER }}:8000/health; then
            echo "✅ Production health check passed"
          else
            echo "❌ Production health check failed"
            exit 1
          fi
          
          # Test homepage
          HOMEPAGE_SIZE=$(curl -s http://${{ env.PRODUCTION_SERVER }}:8000/ | wc -c)
          if [ "$HOMEPAGE_SIZE" -gt 1000 ]; then
            echo "✅ Homepage accessible (${HOMEPAGE_SIZE} bytes)"
          else
            echo "❌ Homepage test failed (${HOMEPAGE_SIZE} bytes)"
            exit 1
          fi
          
          # Performance check
          RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' http://${{ env.PRODUCTION_SERVER }}:8000/ || echo "timeout")
          echo "⚡ Response time: ${RESPONSE_TIME}s"
          
          echo "🎉 All health checks passed - deployment verified!"

      - name: 📢 Notify on failure
        if: failure()
        uses: actions/github-script@60a0d83039c74a4aee543508d2ffcb1c3799cdea
        # Pin: actions/github-script@v7 (2025 security - SHA pinned for supply chain protection)
        with:
          script: |
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: '🚨 Production Deployment Failed',
              body: `## 🚨 Production Deployment Alert
              
              **Time**: ${new Date().toISOString()}
              **Server**: ${{ env.PRODUCTION_SERVER }}
              **Commit**: ${{ github.sha }}
              **Workflow**: [${context.workflow}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})
              
              ### ❌ Deployment Failed
              The automated deployment to production has failed.
              
              ### 🔍 Next Steps:
              1. Check the workflow logs for detailed error information
              2. Verify server status and connectivity
              3. Check Docker container status on the production server
              4. Review application logs if the container started
              
              **This issue was automatically created by GitHub Actions.**`,
              labels: ['bug', 'production', 'deployment', 'urgent']
            });